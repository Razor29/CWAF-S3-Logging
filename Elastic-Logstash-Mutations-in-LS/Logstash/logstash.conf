input {
  s3 {
    access_key_id => '' # Enter AWS Access ID with the required permissions
    secret_access_key => '' # Enter AWS Secret Access Key with the required permissions
    region => '' # Enter the AWS region where the S3 is location for example us-east-1
    bucket => "" # Enter the name of the AWS S3 bucket where the logs are located
    codec => "json_lines" 
    prefix => "CWAF-Logs/" #enter the name of the directory where the processed ndjson logs are saved
    type => "cwaf-logs"
    interval => 300 # Fetch interval in seconds (5 minutes)
  }
}


filter {
  mutate {
    add_field => {
      "file" => "%{[@metadata][s3][key]}"
    }
  }

  # Use Ruby to extract last folder and set the event type
  ruby {
    code => "
      s3_key = event.get('file')
      last_folder = File.dirname(s3_key).split('/').last
      event_type = case last_folder
      when 'WAF'
        'cwaf-waf-logs'
      when 'DDoS'
        'cwaf-ddos-logs'
      when 'Bot'
        'cwaf-bot-logs'
      else
        'cwaf-logs'
      end
      event.set('type', event_type)
    "
  }

  if [type] == "cwaf-waf-logs" or [type] == "cwaf-ddos-logs" or [type] == "cwaf-bot-logs" {
  ruby {
    code => "
      s3_key = event.get('file')
      parts = File.dirname(s3_key).split('/')
      tenant_name = parts[-3]  # Two parent directories up

      filename = File.basename(s3_key, '.*')
      if filename.start_with?('rdwr_event_' + tenant_name + '_')
        components = filename['rdwr_event_'.length + tenant_name.length + 1..-1]
        date_index = components.index(/\d{8}H\d{6}_\d{8}H\d{6}/)
        if date_index
          app_name = components[0..date_index-2]
          event.set('tenant_name', tenant_name)
          event.set('application_name', app_name)
        end
      end
    "
  }
}







  # Remove the file field
  mutate {
    remove_field => ["file"]
  }

 if [type] == "cwaf-logs" {
    if [x-forwarded-for] == "-" {
      ruby {
        code => "event.set('x-forwarded-for', nil)"
      }
    }
    if [source_ip] == "" {
      ruby {
        code => "event.set('x-forwarded-for', nil)"
      }
    }
    grok {
      match => { "request" => "%{WORD:method} %{URIPATH:uri} HTTP/%{NUMBER:http_version}" }
    }
    mutate {
      remove_field => ["method", "http_version"]
    }
    date {
      match => ["time", "dd/MMM/yyyy:HH:mm:ss Z"]
      target => "@timestamp"
    }
  }


  if [type] == "cwaf-waf-logs" {
    # Convert epoch time to @timestamp
    date {
        match => ["receivedTimeStamp", "UNIX_MS"]
        target => "@timestamp"
    }
    ruby {
      code => "event.set('time', event.get('@timestamp').time.strftime('%d/%b/%Y:%H:%M:%S %z'))"
    }

    mutate {
      rename => { "destinationIp" => "destination_ip" }
      rename => { "destinationPort" => "destination_port" }
      rename => { "sourceIp" => "source_ip" }
      rename => { "sourcePort" => "source_port" }
    }

    # Rename nested fields
    mutate {
      rename => { "[enrichmentContainer][geoLocation.countryCode]" => "country_code" }
      rename => { "[enrichmentContainer][applicationId]" => "application_id" }
      rename => { "[enrichmentContainer][owaspCategory2021]" => "owasp_category_2021" }
    }

    # Remove unnecessary fields
    mutate {
      remove_field => [ "webApp", "[enrichmentContainer][contractId]", "[enrichmentContainer][tenant]" ]
    }
  }

    if [type] == "cwaf-ddos-logs" {
    # Convert custom time format to @timestamp
    date {
      match => ["time", "dd-MM-yyyy HH:mm:ss"]
      target => "@timestamp"
    }

  # Convert @timestamp back to string format 'dd/MMM/yyyy:HH:mm:ss Z'
    ruby {
      code => "event.set('time', event.get('@timestamp').time.strftime('%d/%b/%Y:%H:%M:%S %z'))"
    }

    mutate {
      rename => { "destinationIP" => "destination_ip" }
      rename => { "destinationPort" => "destination_port" }
      rename => { "sourceIP" => "source_ip" }
      rename => { "sourcePort" => "source_port" }
    }

    # Rename nested fields
    mutate {
      rename => { "[enrichmentContainer][applicationId]" => "application_id" }
      rename => { "[country]" => "country_code" }  # Assuming 'country' is at the root level of the document
    }

    # Remove unnecessary fields
    mutate {
      remove_field => [ "[enrichmentContainer][contractId]", "[enrichmentContainer][tenant]", "[enrichmentContainer][geoLocation.countryCode]" ]
    }
  }
  if [type] == "cwaf-bot-logs" {
    # Convert epoch millisecond time to @timestamp
    date {
      match => ["time", "UNIX_MS"]
      target => "@timestamp"
    }

  # Convert @timestamp back to string format 'dd/MMM/yyyy:HH:mm:ss Z'
    ruby {
      code => "event.set('time', event.get('@timestamp').time.strftime('%d/%b/%Y:%H:%M:%S %z'))"
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://localhost:9200"]
    index => "%{type}-%{+YYYY.MM.dd}"
    # user and password for Elasticsearch if needed
  }
}
